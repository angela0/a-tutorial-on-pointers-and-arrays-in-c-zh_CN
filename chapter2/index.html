<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>Chapter2 指针类型与数组 - C 指针与数组</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Chapter2 \u6307\u9488\u7c7b\u578b\u4e0e\u6570\u7ec4";
    var mkdocs_page_input_path = "chapter2.md";
    var mkdocs_page_url = null;
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> C 指针与数组</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../preface/">前言</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../introduction/">介绍</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../chapter1/">Chapter1 什么是指针</a>
	    </li>
          
            <li class="toctree-l1 current">
		
    <a class="current" href="./">Chapter2 指针类型与数组</a>
    <ul class="subnav">
            
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../chapter3/">Chapter3 指针与字符串</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../chapter4/">Chapter4 再谈字符串</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../chapter5/">Chapter5 指针与结构体</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../chapter6/">Chapter6 字符串新谈及字符串数组</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../chapter7/">Chapter7 再谈多维数组</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../chapter8/">Chapter8 指向数组的指针</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../chapter9/">Chapter9 指针与动态分配内存</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../chapter10/">Chapter10 指向函数的指针</a>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../epilog/">尾声</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">C 指针与数组</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>Chapter2 指针类型与数组</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <p>好了，来到第二章。让我们讨论一下为什么在声明指针变量时要指明指向的<strong><em>类型</em></strong>，像下面这样：</p>
<pre><code>    int *ptr;
</code></pre>

<p>一个理由就是，一旦 <code>ptr</code> “指向”某物，如我们这样写：</p>
<pre><code>    *ptr = 2;
</code></pre>

<p>编译器就知道该拷贝多少字节到 <code>ptr</code> 指向的内存地址。如果 <code>ptr</code> 被声明用来指向一个 int，会拷贝 2 字节；而指向 long，就拷贝 4 字节。对于 float 和 double 类型是类似的，将拷贝相应大小的字节。指明指针指向变量的类型让编译器有很多有趣的解释代码的方式。比如，10 个整数在一行，可以认为在内存里组成了一个块。这样的话，就会留出 20 字节的内存去放 10 个整数。</p>
<p>现在，让我们把 <code>ptr</code> 指向第一个整数。并且假定这个整数在内存中的位置是100（10进制），如果我们像下面这样写，会发生什么：</p>
<pre><code>    ptr + 1;
</code></pre>

<p>因为编译器知道 <code>ptr</code> 是一个指针（就是说它的值是一个地址）并且指向一个整数（ <code>ptr</code> 当前的值 100 就是这个整数的地址），所以它会给 <code>ptr</code> 加上 2 而不是 1，因此 <code>ptr</code> 会指向位于内存中 102 的位置的<strong>下一个整数</strong>。同样，如果 <code>ptr</code> 指向 long 类型，就会加上 4。其他数据类型，如 float、double，甚至是自定义的结构体也是一样的。很明显这跟我们平时的加法不一样。在 C 语言里面它指的是“指针运算”，这个术语我们后面会提到。</p>
<p>另外，既然 <code>ptr++</code> 和 <code>++ptr</code> 都相当于 <code>ptr+1</code>（虽然加的时间点会有一点差异），那么指针用一元运算符 <code>++</code> 的时候 -- 无论是前置还是后置的 -- <code>ptr</code>里面的地址都会增加 <code>sizeof(type)</code>，这里的 <code>type</code> 是 <code>ptr</code> 指向的对象的类型（如 <code>sizeof(int)</code> 是 2，<code>sizeof(long)</code> 是 4 等）。</p>
<p>根据定义，一块 10 个整数连续放在内存中，就是一个整型数组，这样就引入了数组和指针之间的有趣关系。</p>
<p>看看下面这个语句：</p>
<pre><code>    int my_array[] = {1,23,17,4,-5,100};
</code></pre>

<p>这里是一个包含 6 个整数的数组，我们可以通过 <code>my_array</code> 的下标来引用这些整数，如 <code>my_array[0]</code> 和 <code>my_array[5]</code>。也可以使用指针引用：</p>
<pre><code>    int *ptr;
    ptr = &amp;my_array[0]; /* point our pointer at the first
                            integer in our array */
</code></pre>

<p>这样，我们就可以打印数组，数组索引和指针的方式都可以。下面的代码能说明这一点：</p>
<pre><code>    ----------- Program 2.1 -----------------------------------
    /* Program 2.1 from PTRTUT10.HTM 6/13/97 */

    #include &lt;stdio.h&gt;
    int my_array[] = {1,23,17,4,-5,100};
    int *ptr;
    int main(void)
    {
        int i;
        ptr = &amp;my_array[0]; /* point our pointer to the first
        element of the array */
        printf(&quot;\n\n&quot;);
        for (i = 0; i &lt; 6; i++)
        {
            printf(&quot;my_array[%d] = %d &quot;,i,my_array[i]); /*&lt;-- A */
            printf(&quot;ptr + %d = %d\n&quot;,i, *(ptr + i)); /*&lt;-- B */
        }
        return 0;
    }
</code></pre>

<p>编译运行上面的代码，细心的话你会注意到，行A和行B会打印相同的值。另外观察一下行B里我们逆引用指针的方式：先把 <code>ptr</code> 加上  <code>i</code>，然后才逆引用。把行B改成下面这行：</p>
<pre><code>    printf(&quot;ptr + %d = %d\n&quot;,i, *ptr++);
</code></pre>

<p>运行试试。再改成这行：</p>
<pre><code>printf("ptr + %d = %d\n",i, *(++ptr));
</code></pre>
<p>运行试试。每次测试先猜一下输出，再仔细看看实际的输出。</p>
<p>在 C 里面，标准规定使用 <code>&amp;var_name[0]</code> 的地方可以换成 <code>var_name</code>，因此，刚才的这行代码：</p>
<pre><code>    ptr = &amp;my_array[0];
</code></pre>

<p>可以换成：</p>
<pre><code>    ptr = my_array;
</code></pre>

<p>能够得到同样的结果。</p>
<p>但这样让很多人认为数组的名字是一个指针。我心里更愿意认为“数组的名字是数组中第一个元素的地址”。很多初学者（包括我刚开始学的时候）认为它是一个指针，就会感到很困惑。举个例子，我们可以这样写：</p>
<pre><code>    ptr = my_array;
</code></pre>

<p>但不能下面这样：</p>
<pre><code>    my_array = ptr;
</code></pre>

<p>原因是 <code>ptr</code> 是一个变量，而 <code>my_array</code> 是一个常量。也就是，一旦 <code>my_array[]</code> 被声明，它的第一个元素的位置就不能被改变了。</p>
<p>早些在我们讨论左值的时候，我引用了 <strong>K&amp;R-2</strong> 的话：</p>
<blockquote>
<p>"<strong>对象</strong>是命名了的储存区域，而<strong>左值</strong>就是引用了一个对象的表达式。"</p>
</blockquote>
<p>这引出了一个有趣的问题。既然  <code>my_array</code> 是一个命名了的存储区域，那为什么上面那个赋值语句中的 <code>my_array</code> 不是一个左值呢？为了解释这个问题，一些人就把 <code>my_array</code> 当作“不能改变的左值”。</p>
<p>把示例程序中的：</p>
<pre><code>    ptr = &amp;my_array[0];
</code></pre>

<p>改成：</p>
<pre><code>    ptr = my_array;
</code></pre>

<p>再次运行，验证一下结果是不是完全一样的。</p>
<p>现在，让我们深挖一下上面用到的 2 个名字 <code>ptr</code> 和 <code>my_array</code> 之间的不同。一些人认为数组名就是一个<strong><em>常量</em></strong>指针。我们该怎么理解呢？为了理解这个概念中的术语“常量”，不妨让我们回过头看看“变量”的定义。当我们声明一个变量的时候，会在内存中留出一个位置存放相应类型的值。这些做完后，变量的名字可以有 2 种解释。当用在赋值操作符左边时，编译器会把它当作内存地址，将赋值操作符右边的计算结果拷贝到这个地址。但当我们用在右边时，这个名字就会被解释成存储在该变量所在内存地址里面的内容。</p>
<p>想到这些，让我们看看一种最简单的常量：</p>
<pre><code>    int i, k;
    i = 2;
</code></pre>

<p>这里的 <code>i</code> 是一个变量，会在内存中的数据段占有一段空间。2 是一个常量，  就本身而论，不会在数据段留出内存空间，而是直接放在（嵌入）代码段。这样的话，当我们写了类似 <code>k = i;</code> 的语句时，编译器就会创建代码，在运行时查看内存地址 <code>&amp;i</code> 处，算出值并拷贝给 <code>k</code>；而 <code>i = 2;</code> 这样的语句，编译器会简单地把代码中的 2 给 i，不会引用数据段的。换言之，<code>k</code> 和 <code>i</code> 都是对象，而 2 不是。</p>
<p>类似的，在前面的代码中，因为 <code>my_array</code> 是常量，那么一旦编译器建立好数组自己存储的位置，它就“知道”了 <code>my_array[0]</code> 的地址。一看到：</p>
<pre><code>    ptr = my_array;
</code></pre>

<p>编译器会简单地把这个地址当作是代码段中的常量，即不会引用数据段。</p>
<p>这里应该很好解释了 Chapter 1 中 Program 1.1 使用的 <code>(void *)</code> 表达式（译注：将地址强制转换成指针）。如我们所看到的，我们可以有各种类型的指针。迄今为止，我们讨论了整型指针和字符型指针。未来的章节，我们会学习到结构体指针和指针的指针。</p>
<p>前边我们提到，在不同的系统上指针的大小是不一样的。同样，这也说明指针的大小可以根据它指向对象的类型改变。因此，像整型那样，把 long 赋给一个 short 会遇到麻烦；同样，把不同类型的指针的值赋给其他类型的指针也会遇到麻烦。</p>
<p>为了简化这个问题，C 提供了一个 void 类型的指针。我们可以这样声明：</p>
<pre><code>    void *vptr;
</code></pre>

<p>void 指针算是一种泛型指针。例如，C 不允许整型指针和字符型指针进行比较，但他们中的任意一个都可以和 void 指针比较。当然，其他类型也是如此，强制类型转换可以在合适情况下从一种类型的指针转换成其他类型。在 Chapter 1 的 Program 1.1 里，我就将 int 指针转换成 void 指针，以使他们和 <code>%p</code> 相匹配。在随后的章节我们会谈到其他强制转换的原因。</p>
<p>好了，已经有不少技术性的东西要去理解吸收。我不期望一个初学者能够在第一次度的时候就完全掌握。随着时间和经验的增加，你可能会要回过头来再读一下前 2 章。但是现在，就让我们去看看指针、字符数组以及字符串之间的关系吧。</p>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../chapter3/" class="btn btn-neutral float-right" title="Chapter3 指针与字符串">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../chapter1/" class="btn btn-neutral" title="Chapter1 什么是指针"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../chapter1/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../chapter3/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
