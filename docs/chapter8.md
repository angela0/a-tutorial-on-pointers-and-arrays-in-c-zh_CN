指针当然是可以“指向”所有类型的数据对象，包括数组。然而很明显，当我们讨论 program 3.1 的时候，问题扩展成多维数组的话我们该怎么做，这很重要。

回顾一下，在 Chapter 2 我们说，给定一个整型数组，我们可以用整型指针指向这个数组：

```
    int *ptr;
    ptr = &my_array[0];     /* point our pointer at the first
                            integer in our array */
```

就像我们声明的那样，指针的类型必须和数组第一个元素的类型一样。

此外，我们可以设计一个处理数组的函数，用指针作为形参。如这样：

```
    int array[3] = {'1', '5', '7'};
    void a_func(int *p);
```

有的参数可能会写成这样：

```
    void a_func(int p[]);
```

这会告诉别人这个函数是用来处理数组的元素。当然，不管哪种情况传过去的都是指向数组第一个元素的指针，和在函数原型或者定义中使用哪种符号无关（`int *p` 或者 `int p[]`）。需要注意到的是，如果我们用了数组符号，并不需要将传递数组的实际大小，因为我们不是要传递整个数组，只是第一个元素的地址。

我们现在将问题转向二维数组。就像我们上一章说的那样，C 会把二维数组解释为一维数组的数组。在那个例子中，二维整型数组的第一个元素是一个一维整型数组。并且，指向二维数组的指针必须是这种数据类型。实现这个的一种方法是使用关键字 “typedef”，它会给指定的数据类型分配一个新名字。如：

```
    typedef unsigned char byte;
```

因为 `byte` 就是 `unsigned char`，因此：

```
    byte b[10]; //会是一个unsigned characters类型的数组
```

注意到，在 typedef 声明中，`byte` 取代了我们正常使用的 `unsigned char`。可以看出，typedef 的使用规则是，这个数据类型的新名字就是在这个数据类型定义中用的名字。因此，在：

```
    typedef int Array[10];
```

`Array` 成了包含10个整数的数组类型，如 `Array my_arr;` 声明了变量 `my_arr`，它是一个含有 10 个整数空间的数组；还有 `Array arr2d[5];`，它是一个二维数组，含有 5 个元素，每个元素是一个 10 个整数的数组。

另外，注意到`Array *p1d;` 会声明一个指向 10 个整数的数组的指针。因为 `p1d` 指向的类型和 `arr2d` 相同，所以把二维数组 `arr2d` 的地址赋给指向包含 10 个整数的一维数组的指针 `p1d` 是可以接受的。即 `p1d = &arr2d[0];` 或者 `p1d = arr2d;`都是正确的。
    
既然我们使用的指针的类型是 10 个整数的数组，我们期望 `p1d+1` 会增加 `10*sizeof(int)`，它确实是这样。也就是说，`sizeof(*p1d)` 就是 20。你可以写一个简单的程序验证一下。

当使用 typedef 的时候，读者读起来会很清晰，程序员也会很方便，但它却不是必须的。我们需要不使用 `typedef` 关键字来声明一个像 `p1d` 这样的指针。事实证明确实可以，这样：

```
    int (*p1d)[10];
```

就是正确的做法。这里 `p1d` 就是一个指向 10 个整数的数组的指针，和上面使用 Array 声明的一样。但请注意，这个：

```
    int *p1d[10];
```

是不一样的，这个 `p1d` 是含有 10 个 `int` 类似指针的数组名。
