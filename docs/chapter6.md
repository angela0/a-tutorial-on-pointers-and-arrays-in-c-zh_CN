好吧，让我们再次回到字符串。下面所有的赋值语句都理解成全局的，即在所有函数外面，包括 main 函数。

我们在之前的章节说过，这样写：

```
    char my_string[40] = "Ted";
```

会给这 40 字节的数组分配空间，并把这个字符串放在前 4 个字节（3 个引号中的字符和一个 `'\0'`）。

实际上，如果我们只是想存储 "Ted" 这个名字，完全可以这样写：

```
    char my_name[] = "Ted";
```

编译器会数出字符数，并留出 nul 字符的空间，将这所有的 4 个字符存到内存中。位置将被返回给数组名，这个例子中是 `my_name`。

在有的代码中，你可能会看到这样，而不是上面那种：

```
    char *my_name = "Ted";
```

这也是一种方法。它们有什么不同吗？答案是 ... 确实有。用数组符号的话，将会在内存的 static 区分配 4 字节内存，3 个字符加上 nul 字符。但是用指针的形式，除了这 4 个字节之外，**加上** N 个字节去存指针变量 `my_name`（N 取决于你的系统，最少 2 个字节，或者 4 个，或者更多）。

在数组声明中，`my_name` 是 `&myname[0]` （数组第一个元素的地址）的简写，既然数组的地址在运行的时候是固定的，那么它是一个常量（不是变量）。在指针声明中 `my_name` 却是一个变量。哪一个**更好**？这取决于你的程序要干什么。

现在，让我们更进一步看看，如果每个声明都放在函数里面，而不是全局的会怎么样：

```
    void my_function_A(char *ptr)
    {
        char a[] = "ABCDE"
        //...
        //...
    }
    
    void my_function_B(char *ptr)
    {
        char *cp = "FGHIJ"
        .
        .
    }
```

在 `my_function_A` 中，数组 `a[]` 的内容或者说是值，被当作数据。数组被初始化为 "ABCDE"；而在 `my_function_B` 里面，指针 `cp` 的值被当作数据，被初始化为指向字符串 "FGHIJ"。无论是在 `my_function_A` 中还是 `my_function_B` 中，定义都是局部变量，因此字符串 "ABCDE" 被存放在栈中，和指针 `cp` 的值一样。但字符串 "FGHIJ" 却可以存在任意地方。在我的系统中，它被存放在数据段。

顺便一提，像上面 `my_function_A` 中那样的数组自动变量初始化，在老的 K&R C 中是非法的，到 ANSI C 中才“到达合法年龄”。事实上，当考虑可移植性和反向兼容性的时候这会很重要。

既然我们在讨论指针和数组的关系/诧异，那让我们看看多位数组。如下面这个数组：

```
    char multi[5][10];
```

这是什么意思呢？让我们看看下面。

char <span style="text-decoration:underline">multi[5]</span>[10];

我们把下划线的那部分当作数组的“名字”，根据前面的 `char` 和后面的，我们 `[10]`，我们可以有一个10字符的数组。但是 `multi[5]` 这个名字本身就是一个数组，它有 5 个元素，每个元素是一个 10 个字符的数组。因此，我们得到一个 5 个元素的数组，每个元素 10 个字符。

假设我们用某些数据填充了这个二维数组。在内存中，它可能看起来像初始化 5 个独立的数组一样：

```
    multi[0] = {'0','1','2','3','4','5','6','7','8','9'}
    multi[1] = {'a','b','c','d','e','f','g','h','i','j'}
    multi[2] = {'A','B','C','D','E','F','G','H','I','J'}
    multi[3] = {'9','8','7','6','5','4','3','2','1','0'}
    multi[4] = {'J','I','H','G','F','E','D','C','B','A'}
```

并且，每个元素都可以用这样的语法来寻址：

```
    multi[0][3] = '3'
    multi[1][7] = 'h'
    multi[4][0] = 'J'
```

既然数组在内存中是连续的，上面的数组在实际的内存中应该是这样：

```
    0123456789abcdefghijABCDEFGHIJ9876543210JIHGFEDCBA
    ^
    |_____ starting at the address &multi[0][0]
```

需要注意的是，我没有写 `multi[0] = "0123456789";`，这样的话， `'\0'` 会自动添加，因为不管什么时候出现双引号 `'\0'` 都会被自动加上的。那样的话，我就需要留出 11 字节的空间，而不是 10 个。

我上面的目的是展示二维数组在内存中是怎样排列的。并且，这是一个二维字符数组，**并不是**“字符串数组”。

现在，编译器知道数组中有多少列，因此它能解释 `multi + 1` 为第二行中 `'a'` 的地址。那是因为，它加了列数 10，得到了这个位置。如果我们处理的是整数并且是同样维数的数组 ，编译器会加上 `10*sizeof(int)`，在我的机器上是 20。因此第四行中 9 的地址将表示成 `&multi[3][0]` 或者指针形式 `*(multi + 3)`。为了得到第四行第二个元素，我们把这个地址加 1，并进行解引用：

```
    *(*(multi + 3) + 1)
```

稍微总结一下，可以得到下面的结论：

```
    *(*(multi + row) + col)         and
    multi[row][col]                 yield the same results.
```

下面的程序用整型数组，而不是字符数组，展示了这一点：

```
    //------------------- program 6.1 ----------------------
    /* Program 6.1 from PTRTUT10.HTM 6/13/97*/
    #include <stdio.h>
    #define ROWS 5
    #define COLS 10
    int multi[ROWS][COLS];
    int main(void)
    {
        int row, col;
        for (row = 0; row < ROWS; row++)
        {
            for (col = 0; col < COLS; col++)
            {
                multi[row][col] = row*col;
            }
        }
        for (row = 0; row < ROWS; row++)
        {
            for (col = 0; col < COLS; col++)
            {
                printf("\n%d ",multi[row][col]);
                printf("%d ",*(*(multi + row) + col));
            }
        }
        return 0;
    }
    //----------------- end of program 6.1 ---------------------
```

因为这个指针版本需要 2 次解引用，二维数组的名字经常被说成与指针的指针等价。对于一个三维数组，可以认为在处理一个数组的数组的数组，有人认为它的名字和指针的指针的指针等价。然而，我们通过数组符号为这个数组初始留出内存块，因此，我们处理的是一个常量，而不是变量。这就是我们讨论的一个固定的内存地址，不是一个可变指针变量。上面用到的逆引用功能运行我们访问数组的数组中的任何元素，而不需要改变那个值（`multi[0][0]` 的地址通过 `mutil` 这个符号给出）。
