字符串的学习能够让我们深入融合指针和数组的关系。也更加容易说明一些标准 C 字符串函数如何执行。最后，它能说明什么时候我们能够和应该给函数传递指针。

在 C 里面，字符串是一个字符输出。在其他语言里面不一定是这样。在 BASIC、Pascal、Fortran 以及其他一些语言里面，字符串是一种单独的数据类型。但在 C 中，字符串就是一个以 zero 字符（写作 `'\0'`）结尾的字符数组。为了开始我们的讨论，我们会先写一些代码，这些代码只为了说明问题，实际中可能不会用到。看看这段代码：

```
    char my_string[40];
    my_string[0] = 'T';
    my_string[1] = 'e';
    my_string[2] = 'd':
    my_string[3] = '\0';
```

虽然不会有人这样建立一个字符串，但一个以 *nul字符结尾* 的字符数组最终结果就是一个字符串。因为根据定义，以 *nul字符结尾*  的字符数组就是一个字符串。注意这里 `nul`，和 `NULL` 并不一样。`nul` 指的是转义的 0（`'\0'`），所以它要占用一个字节的内存。而 `NULL`，用于初始化 null 指针的宏定义。`NULL` 在你用的 C 编译器的某个头文件中以 `#define` 的方式定义，而 `nul` 可能没有。

既然上面这种写法很浪费时间，C 语言也允许下面这 2 种写法。第一个，这样写：

```
    char my_string[40] = {'T', 'e', 'd', '\0',};
```

但这似乎还是多敲这么多字符，不太方便。所以，C 也允许这种写法：

```
    char my_string[40] = "Ted";
```

当我们使用双引号，而不是单引号，像上面这个例子一样，nul 字符（`'\0'`）会被自动加在字符串尾。

在上面 3 个例子中，结果都是一样的。编译器会留出 40 字节的空间去存放字符，并将前 4 字节初始化为 `Ted\0`。

看看下面这段程序：

```
    ------------------program 3.1-------------------------------------
    /* Program 3.1 from PTRTUT10.HTM 6/13/97 */
    #include <stdio.h>
    char strA[80] = "A string to be used for demonstration purposes";
    char strB[80];
    int main(void)
    {
        char *pA;   /* a pointer to type character */
        char *pB;   /* another pointer to type character */
        puts(strA); /* show string A */
        pA = strA;  /* point pA at string A */
        puts(pA);   /* show what pA is pointing to */
        pB = strB;  /* point pB at string B */
        putchar('\n');      /* move down one line on the screen */
        while(*pA != '\0')  /* line A (see text) */
        {
            *pB++ = *pA++;  /* line B (see text) */
        }
        *pB = '\0';         /* line C (see text) */
        puts(strB);         /* show strB on screen */
        return 0;
    }
    --------- end program 3.1 -------------------------------------
```

在上面的代码中，我们一开始定义了 2 个 80 字符长的字符数组。因为是全局变量，它们会先被初始化为 `'\0'`，然后 `strA` 的前 42 字节被初始化为引号里面的字符串。

现在看看代码，我们声明了 2 个字符指针，并把字符串打印到屏幕上。然后用 `pA` “指向”了 `strA`。也就是说，我们通过赋值运算符把 `strA[0]` 的地址给了变量 `pA`。然后用 `puts()` 函数把 `pA` 指向的内容打印到屏幕上。这里看看函数 `puts()` 的原型：

```
    int puts(const char *s);
```

暂时忽略这个 `const`，发现传给 `puts()` 的参数是一个指针，也就是指针的值（因为 C 语言的参数是传值的），并且指针的值就是它所指向的地址，或者简单的说就是一个地址。因此，当我们写 `puts(strA);` 时，如我们所见，我们把 `strA[0]` 的地址传递了过去。

同样，如果我们写了 `puts(pA);`，会传递过去相同的地址，因为我们前面有这句话：`pA = strA;`。

这样，一直到 line A 处的 `while()` 语句。line A 处表示：只要 `pA` 指向的字符（即 `*pA`）不是 nul 字符（即终止符`'\0'`），就：

把 `pA` 指向的字符拷贝到 `pB` 指向的空间，并自增 `pA` 使其指向下一个字符，自增 `pB` 指向下一个空间。

当我们拷贝完最后一个字符的时候，`pA` 指向 nul 字符，循环就会结束。然而我们没有拷贝 `'\0'`。但是根据定义字符串**必须**以 nul 字符结尾，所以在 line C  处我们手动加上了 `'\0'`。

如果能用单步调试运行这段程序，并观察 `strA`，`strB`，`pA` 以及 `pB`，那将十分有教育性。如果能在定义 `strB[]` 的时候如下初始化就更好了：

```
    strB[80] = "12345678901234567890123456789012345678901234567890"
```

这里数字的数量要比 `strA` 的长度长一些。重复单步调试的步骤并观察那几个变量。试试吧。

回头说说 `puts()` 的原型，这个 `const` 被用作参数修饰，告诉用户这个函数是不会修改该指针指向的字符串，也就是把这个字符串当作常量。

当然，上面的代码只是展示了一种拷贝字符串的简单方法。把玩一下这段代码，到你能对它发生了什么有一个好的理解之后，我们就能够创建自己的 `strcpy()` 函数了。它大概就是这个样子：

```
    char *my_strcpy(char *destination, char *source)
    {
        char *p = destination;
        while (*source != '\0')
        {
            *p++ = *source++;
        }
        *p = '\0';
        return destination;
    }
```

在这个例子中，我遵从标准程序中返回一个指针的惯例。

重申一遍，这个函数被设计成接收 2 个字符指针的值，也就是地址，因此前面的程序中可以这样写：

```
    int main(void)
    {
        my_strcpy(strB, strA);
        puts(strB);
    }
```
    
其实在上面的 `my_strcpy()` 函数中，我稍稍偏离了标准 C 的格式，它事实上的原型应该是这样：

```
    char *my_strcpy(char *destination, const char *source);
```

这里的 `const` 修饰确保这个函数不会修改 `source` 指针指向的内容。你可以像上面那样加上 `const` 修饰证实一下。然后在函数里面，你可以增加一个尝试修改 `source` 指针所指内容的语句，像这样：

```
    *source = 'X';
```

这句话是把字符串的第一个字符改为 `X`，因为 `const` 的原因，你的编译器会捕捉到这个错误。试试看。

现在，让我们看看上面示例中的一些问题。首先，你应该明白， `*ptr++` 被理解成返回 `ptr` 指向的值并且自增 `ptr` 的值。这和运算符的优先级有关。如果我们写成 `(*ptr)++`，则会自增 `ptr` 指向的值，而不是 `ptr` 的值。比如，我们把它用在上面样例字符串的第一个字符，'T' 会变成 'U'。你可以写一些简单的样例代码验证一下。

再次强调，字符串不是别的东西，就是一个结尾为 '\0' 的字符数组。我们前面做的只是拷贝字符串。它恰好是字符串数组，不过这个方法也用在 int 数组、double 数组上面。但在这些数组中，因为不是字符串，所有没有必要在尾部加上像 nul 字符这样的特殊值。但我们可以实现一个这样的版本，依靠一个特殊值来标识结尾。如，我们拷贝一个正整数数组，可以在尾部标记一个负数。另外，我们写一个函数来拷贝一个数组，不是字符串，可以和数组地址一起把元素个数传递过去，这十分有用。比如，可以像下面这个声明原型一样：

```
    void int_copy(int *ptrA, int *ptrB, int nbr);
```

这里的 `nbr` 是将要被拷贝的整数个数。你可能像实验一下这个想法。创建一个整数数组，看看你能不能写出能正确工作的 `int_copy()` 函数。

有了指针，就允许用函数来处理大的数组。比如，假如我们有一个 5000 个整数的数组，并且要用函数处理，我们可以只传递数组的指针（和一些如上面提到的 `nbr` 这样的辅助信息，这取决你你在做什么）。这个数组本身并没有传递过去。也就是说，整个数组没有在调用函数的时候被复制放到栈里面，而只有它的地址。

这跟传递一个整数给函数不一样。当我们传递一个整数的时候，我们拷贝了一份这个整数。就是取得整数的值，并放到栈里面。在函数里面操作传过来的值对原来的值没有影响。但对于数组和指针，我们可以传递变量的地址，因此可以操作原来变量的值。
