好了，来到第二章。让我们讨论一下为什么在声明指针变量时要指明指向的***类型***，像下面这样：

```
    int *ptr;
```

一个理由就是，一旦 `ptr` “指向”某物，如我们这样写：

```
    *ptr = 2;
```

编译器就知道该拷贝多少字节到 `ptr` 指向的内存地址。如果 `ptr` 被声明用来指向一个 int，会拷贝 2 字节；而指向 long，就拷贝 4 字节。对于 float 和 double 类型是类似的，将拷贝相应大小的字节。指明指针指向变量的类型让编译器有很多有趣的解释代码的方式。比如，10 个整数在一行，可以认为在内存里组成了一个块。这样的话，就会留出 20 字节的内存去放 10 个整数。

现在，让我们把 `ptr` 指向第一个整数。并且假定这个整数在内存中的位置是100（10进制），如果我们像下面这样写，会发生什么：

```
    ptr + 1;
```

因为编译器知道 `ptr` 是一个指针（就是说它的值是一个地址）并且指向一个整数（ `ptr` 当前的值 100 就是这个整数的地址），所以它会给 `ptr` 加上 2 而不是 1，因此 `ptr` 会指向位于内存中 102 的位置的**下一个整数**。同样，如果 `ptr` 指向 long 类型，就会加上 4。其他数据类型，如 float、double，甚至是自定义的结构体也是一样的。很明显这跟我们平时的加法不一样。在 C 语言里面它指的是“指针运算”，这个术语我们后面会提到。

另外，既然 `ptr++` 和 `++ptr` 都相当于 `ptr+1`（虽然加的时间点会有一点差异），那么指针用一元运算符 `++` 的时候 -- 无论是前置还是后置的 -- `ptr`里面的地址都会增加 `sizeof(type)`，这里的 `type` 是 `ptr` 指向的对象的类型（如 `sizeof(int)` 是 2，`sizeof(long)` 是 4 等）。

根据定义，一块 10 个整数连续放在内存中，就是一个整型数组，这样就引入了数组和指针之间的有趣关系。

看看下面这个语句：

```
    int my_array[] = {1,23,17,4,-5,100};
```

这里是一个包含 6 个整数的数组，我们可以通过 `my_array` 的下标来引用这些整数，如 `my_array[0]` 和 `my_array[5]`。也可以使用指针引用：

```
    int *ptr;
    ptr = &my_array[0]; /* point our pointer at the first
                            integer in our array */
```

这样，我们就可以打印数组，数组索引和指针的方式都可以。下面的代码能说明这一点：

```
    ----------- Program 2.1 -----------------------------------
    /* Program 2.1 from PTRTUT10.HTM 6/13/97 */
   
    #include <stdio.h>
    int my_array[] = {1,23,17,4,-5,100};
    int *ptr;
    int main(void)
    {
        int i;
        ptr = &my_array[0]; /* point our pointer to the first
        element of the array */
        printf("\n\n");
        for (i = 0; i < 6; i++)
        {
            printf("my_array[%d] = %d ",i,my_array[i]); /*<-- A */
            printf("ptr + %d = %d\n",i, *(ptr + i)); /*<-- B */
        }
        return 0;
    }
```

编译运行上面的代码，细心的话你会注意到，行A和行B会打印相同的值。另外观察一下行B里我们逆引用指针的方式：先把 `ptr` 加上  `i`，然后才逆引用。把行B改成下面这行：

```
    printf("ptr + %d = %d\n",i, *ptr++);
```

运行试试。再改成这行：

    printf("ptr + %d = %d\n",i, *(++ptr));
    
运行试试。每次测试先猜一下输出，再仔细看看实际的输出。

在 C 里面，标准规定使用 `&var_name[0]` 的地方可以换成 `var_name`，因此，刚才的这行代码：

```
    ptr = &my_array[0];
```

可以换成：

```
    ptr = my_array;
```

能够得到同样的结果。

但这样让很多人认为数组的名字是一个指针。我心里更愿意认为“数组的名字是数组中第一个元素的地址”。很多初学者（包括我刚开始学的时候）认为它是一个指针，就会感到很困惑。举个例子，我们可以这样写：

```
    ptr = my_array;
```

但不能下面这样：

```
    my_array = ptr;
```

原因是 `ptr` 是一个变量，而 `my_array` 是一个常量。也就是，一旦 `my_array[]` 被声明，它的第一个元素的位置就不能被改变了。

早些在我们讨论左值的时候，我引用了 **K&R-2** 的话：

>"**对象**是命名了的储存区域，而**左值**就是引用了一个对象的表达式。"
    
这引出了一个有趣的问题。既然  `my_array` 是一个命名了的存储区域，那为什么上面那个赋值语句中的 `my_array` 不是一个左值呢？为了解释这个问题，一些人就把 `my_array` 当作“不能改变的左值”。

把示例程序中的：

```
    ptr = &my_array[0];
```

改成：

```
    ptr = my_array;
```

再次运行，验证一下结果是不是完全一样的。

现在，让我们深挖一下上面用到的 2 个名字 `ptr` 和 `my_array` 之间的不同。一些人认为数组名就是一个***常量***指针。我们该怎么理解呢？为了理解这个概念中的术语“常量”，不妨让我们回过头看看“变量”的定义。当我们声明一个变量的时候，会在内存中留出一个位置存放相应类型的值。这些做完后，变量的名字可以有 2 种解释。当用在赋值操作符左边时，编译器会把它当作内存地址，将赋值操作符右边的计算结果拷贝到这个地址。但当我们用在右边时，这个名字就会被解释成存储在该变量所在内存地址里面的内容。

想到这些，让我们看看一种最简单的常量：

```
    int i, k;
    i = 2;
```

这里的 `i` 是一个变量，会在内存中的数据段占有一段空间。2 是一个常量，  就本身而论，不会在数据段留出内存空间，而是直接放在（嵌入）代码段。这样的话，当我们写了类似 `k = i;` 的语句时，编译器就会创建代码，在运行时查看内存地址 `&i` 处，算出值并拷贝给 `k`；而 `i = 2;` 这样的语句，编译器会简单地把代码中的 2 给 i，不会引用数据段的。换言之，`k` 和 `i` 都是对象，而 2 不是。

类似的，在前面的代码中，因为 `my_array` 是常量，那么一旦编译器建立好数组自己存储的位置，它就“知道”了 `my_array[0]` 的地址。一看到：

```
    ptr = my_array;
```

编译器会简单地把这个地址当作是代码段中的常量，即不会引用数据段。

这里应该很好解释了 Chapter 1 中 Program 1.1 使用的 `(void *)` 表达式（译注：将地址强制转换成指针）。如我们所看到的，我们可以有各种类型的指针。迄今为止，我们讨论了整型指针和字符型指针。未来的章节，我们会学习到结构体指针和指针的指针。

前边我们提到，在不同的系统上指针的大小是不一样的。同样，这也说明指针的大小可以根据它指向对象的类型改变。因此，像整型那样，把 long 赋给一个 short 会遇到麻烦；同样，把不同类型的指针的值赋给其他类型的指针也会遇到麻烦。

为了简化这个问题，C 提供了一个 void 类型的指针。我们可以这样声明：

```
    void *vptr;
```

void 指针算是一种泛型指针。例如，C 不允许整型指针和字符型指针进行比较，但他们中的任意一个都可以和 void 指针比较。当然，其他类型也是如此，强制类型转换可以在合适情况下从一种类型的指针转换成其他类型。在 Chapter 1 的 Program 1.1 里，我就将 int 指针转换成 void 指针，以使他们和 `%p` 相匹配。在随后的章节我们会谈到其他强制转换的原因。

好了，已经有不少技术性的东西要去理解吸收。我不期望一个初学者能够在第一次度的时候就完全掌握。随着时间和经验的增加，你可能会要回过头来再读一下前 2 章。但是现在，就让我们去看看指针、字符数组以及字符串之间的关系吧。
