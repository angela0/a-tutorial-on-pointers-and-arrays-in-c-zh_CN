不可避免地，C 语言新手觉得指针的概念很难理解。这个教程的目的就是给这些新手一些指针的介绍以及使用。

我发现新手们的指针问题的主要原因是，他们对变量（当然是 C 中的变量）的感觉很弱，甚至说是微乎其微。因此，我们先大体上从 C 的变量讨论一下。

程序中的变量就是一件有名字的东西，他的值是可以改变的。编译器和连接器处理它的方式是在计算机的内存中分配一个块去放该变量的值。块的大小取决于这个变量的值允许改变的范围。比如，在 PC 里，整型变量的大小是 2 字节，而长整型的大小是 4 字节。在 C 里面，一个如整型这样的变量类型，由于机器的不同，其大小也不尽相同。

但我们声明一个变量的时候，我们给编译器传递了 2 个信息：变量的名字和变量的类型。例如，我们声明一个叫 `k` 的整型变量可以这样写：

```
    int k;
```
    
一看到这个语句里 “int” 这一部分，编译器就会分配 2 字节内存去放这个整数的值。编译器会建一个符号表，并在分配内存的同时将这个符号 `k` 以及与之关联的内存地址加进去。

因此，如果我们下面这样写：

```
    k = 2;
```
    
我们期望，在运行的时候执行到这个语句，2 这个值将被放到为 `k` 的值保留的内存地址。在 C 里面，我们称像 `k` 这样的变量为“对象”。

在实际意义上，这里有 2 个值和对象 `k` 有关系。一个是储存在那里的整数值（上面的例子中是 2），另一个是内存地址的值（例子中是 `k` 的地址）。一些文章把这 2 个值分别叫做 **rvalue**（right value 右值, 读作 ‘are value’）和 **lvalue** （left  value 左值, 读作‘el value’）。

在一些语言里面，左值是被允许放在复制操作符 ‘=’ 左边的值（也就是右边表达式计算结果的地址）。右值是在赋值语句的右边，如上面代码中的 2 。右值是不允许放在赋值语句的左边。如 `2 = k` 就是非法的。

实际上，上述左值的定义用在 C 里面的时候稍稍做了修改。根据 *K&R II* (page 197):[^1]

> "**对象**是命名了的储存区域，而**左值**就是引用对象的表达式。"

这样的话，上面引用的定义是很充分的。但我们更加熟悉指针的时候，我们可以探究更多的细节。

好了，我们看看这个：

```
    int j, k;
    
    k = 2;
    j = 7;    <--line 1
    k = j;    <--line 2
```
    
在上面这个例子中，编译器解释 line 1 的`j` 为变量 `j`（它的左值） 的地址，并把值 7 拷贝到那个地址。在 line 2，这时，`j` 就被解释成它的右值（因为它被放到赋值操作符 ‘=’ 右边）。也就是，这里的 `j` 引用**储存**在为变量 `j` 分配的内存地址里面的值，在这个例子中就是 7 。因此 7 被拷贝到有 `k` 的左值指定的地址。

在上面所有例子中，我们都是使用 2 字节的整数，因此，所有右值从一个地方拷贝到另外一个地方都是拷贝 2 个字节。假如我们使用长整型，将会拷贝 4 个字节。

现在，让我们谈谈需要一个变量来存放左值（地址）的原因。存放这样一个值需要的大小取决于系统。在老的 64k 内存的桌面电脑上，内存中任意点的地址都可以用 2 字节表示出来。内存越大，就需要越多的字节去存放一个地址。在一些计算机里，如 **IBM PC** 有时可能需要特殊处理才能放下一个段和偏移量。只要我们能告诉编译器我们要储存的是一个地址，那需要的实际大小便不那么重要了。

这样的变量被称作 **指针变量** （具体原因，马上就能明白）。在 C 里面，当我们定义一个指针变量时，要在变量名前面加一个星号。同样也需要给指针变量一个类型，这个类型就是储存在该指针变量的那个地址里的数据的类型。例如，可以这样声明指针变量：

```
    int *ptr;
```

`ptr` 是变量的名字（就像上面声明的整型变量 `k` 一样）。这个 `*` 告诉编译器我们想要一个指针变量，也就是说，要开辟不管多少个字节的内存空间，被用来存储内存中的地址。 `int` 表明我们要用这个变量去存储一个整数的地址。这样一个指针，可以说成“指向”一个整数。然而要注意的是，当我们写 `int k;` 时，并没有给 `k` 一个值。如果我们把这个语句写在任何函数外面（译注：包括 main 函数），遵循 ANSI 标准的编译器会把它初始化为 0。同样的，`ptr` 没有值，因为在上面的声明中我们没有存储一个地址。在这个例子中，如果我们把声明写在任何函数外面，它应该被初始化一个值，保证它不会指向 C 中的任何对象和函数。 用这种方法初始化的指针，称之为 “null” 指针（译注：即空指针，但后文中都写做 null 指针）。

实际用于 null 指针的位模式可能会也可能不会计算成 0，因为它开发代码的特定系统。为了能让源代码在不同系统上的不同编译器之间兼容，我们使用一个宏定义来表示 null 指针。这个宏叫做 `NULL`。因此，我们把指针的值设置为 `NULL` 的时候，如 `ptr = NULL;` 这样的赋值语句，就保证了这个指针变成一个 null 指针。类似的，就像用 `if(k==0)` 测试一个整数是否为 0 那样，我们可以用 `if(ptr==NULL)` 来测试 `ptr` 是否为 null 指针。

回到我们的新变量 `ptr`上面。假设想要在 `ptr` 中存储变量 `k` 的地址，我们可以使用一元元算符 `&`，这样写：

```
    ptr = &k;
```

`&` 操作符所做的就是取得变量 `k` 的左值（地址），即使它是在赋值操作符右边，并且 `&` 将取得的内容拷贝给我们的指针 `ptr`。现在，我们可以说 `ptr` 指向 `k` 。耐心一点，我们只需要再讨论一个操作符。

“逆引用操作符”（译注：也叫做 间接操作符）就是一个星号，我们这样用：

```
    *ptr = 7;
```

这个语句会把 7 拷贝给 `ptr` 指向的地址。因此如果 `ptr` 指向变量 `k`（有 `k` 的地址），这个语句就会把 `k` 的值设置为 7。也就是说，当我们用 `*` 这种方式时，我们引用的是 `ptr` 指向的那个值，而不是 `ptr` 自身的值。

类似地，我们这样写：

```
    printf("%d\n",*ptr);
```

就可以把 `ptr` 所指地址里存储的值打印到屏幕。

要看看上面这些东西怎么放在一起，就运行一下下面的程序，并自习审查一下代码和输出：

```
    ------------ Program 1.1 ---------------------------------
    
    /* Program 1.1 from PTRTUT10.TXT 6/10/97 */

    #include <stdio.h>
    int j, k;
    int *ptr;
    int main(void)
    {
        j = 1;
        k = 2;
        ptr = &k;
        printf("\n");
        printf("j has the value %d and is stored at %p\n", j, (void *)&j);
        printf("k has the value %d and is stored at %p\n", k, (void *)&k);
        printf("ptr has the value %p and is stored at %p\n", ptr, (void
        *)&ptr);
        printf("The value of the integer pointed to by ptr is %d\n", *ptr);
        return 0;
    }
```

注意：我们必须要讨论这里用到的 `(void *)` 表达式的用法。但这里，先加到你的测试代码里，我们随后会解释原因的。

---

回顾：

- 声明一个变量要给一个类型和一个名字（如：`int k;`）
- 声明一个指针变量同样要给一个类型和一个名字（如： `int *ptr;`），这里的 `*` 告诉编译器我们声明的是一个指针变量，类型则告诉编译器我们声明的指针变量指向的地址存储的是什么类型的数据（在我们的例子中是 `int`）
- 只要声明了一个变量，我们就可以通过在它的名字前加一个一元运算符 `&` 来获取它的地址，如 `&k`
- 我们可以逆引用一个指针，也就是说，可以引用这个指针指向的地址存储的值，只需要像 `*ptr` 这样使用一元运算符 `*` 就可以了
- 变量的左值就是它的地址，也就是它在内存中存储的位置；右值就是在变量中（内存地址中）存储的值。


[^1]: "The C Programming Language" 2nd Edition

    B. Kernighan and D. Ritchie
 
    Prentice Hall
 
    ISBN 0-13-110362-8
